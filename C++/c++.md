# 什么叫编译链接

## 链接模型/分块处理

编译耗费资源，但是处理的输入比较少，能快速完成
链接输入较多，但处理速度很快

- 构造头文件，包含我所需要的声明，然后引用   <---头文件还包含定义

## 翻译单元

 源文件 + 相关头文件 --应该忽略的预处理语句（如果这个宏存在，则执行，不存在则不执行）

## 一处定义原则：

 程序级别：一般函数
 翻译单元： 内连函数， 类， 模板

## 第一个程序流程

 预处理：将源文件变成翻译单元 。（将间直接和直接的翻译单元打开） -->编译：将预处理完的文件main.c变成汇编代码 -->汇编： 将汇编代码生成相应的目标文件（机器码） -->链接：将系统提供的目标文件，放到一起。构造一个可知执行程序

 编译器， 链接是最重要的过程【即编译链接过程】

 预处理：
    将源文件转化为翻译单元的过程;
 编译：
       将翻译单元转为汇编 （编译优化）
 链接：
       合并多个目标文件，关联声明与定义
       连接种类：内部链接（在翻译单元内，看不见）， 外部链接， 无链接
       常见错误：找不到定义

## 控制流的概念

    末尾简单接受结构体和自定义数字类型
   int mian()直接由程序调内部用
   形参可接受的参数类型（空， 可以改为void， 可以无形参数）
   void fun(const char* pInfo, int pValue) --> const char* 其实是指定了pInfo的类型

   $: echo $? ---> 可以看到 int mian()函数的返回值，是返回给计算机.c++标准默认， 如归没有return语句默认返回是0

## 控制系统IO

    从头文件说起 --> 使用头文件来添加头文件 "" 从当前文件路径搜索。<>从操作系统安装库的地方那个查找
                        "" 一般是我们自己编写头文件后的引用
                        std::cerr 和std::clog的区别在于是否立即刷新缓存区， C++的缓存区【内容首先输出到缓冲区，当缓存区满了一次性把文件输出到屏幕上】
                        如果程序的内容放在缓冲区，没有及时向文件存储或屏幕刷新。这个时候程序就崩溃，缓存区的内容就会以被机器回收。所以要及时刷新缓存区。cerr会立即刷新缓存区 clog不立即刷新缓存区。
                        使用cout和clog时，用std::flush; std::endl刷新缓存区
                        std::flush和std::endl的区别：
                                                      std::endl刷新缓存区，且会换行。std::flush不会换行.大量的使用他俩强制刷新缓存区，不是很好的方法，建议必要的时候采取
      std::-->名字空间
            用于解决，名字冲突。
            1.域解析符::   -->使用域解析符调用
            2.using语句    -->
            3.名字空间别名  -->

    名字空间与名称改编
            name mangling 名字改变：
                                    不希望翻译过来的链接包含4个点::这样的符号

## 猜数字与控制流

    if 用于分支选择
            -- 条件部分: 用于判断是否执行
            -- 语句部分： 要执行的操作
      == 判读俩个值是否相等
      const int x ==42； const 是一个限定符，表示x，只读，不可修改！

    while 用于循环结构
            -- 条件部分： 用于判断是否执行
            -- 语句部分： 要执行的操作
            即true时继续执行{}中的code代码，false时跳出循环

    while（condition）
            {
                  conditional code;
            }

## 结构体与自定义数据类型

    结构体更多的时关注于数据  面向对象的编程衍生
      struct --> 能够定义一个结构体 『包含多个数据的组合』
             --点操作符号(.) --> 访问内部亚元素；
             --可以作为函数的输入参数或返回类型；
             --可以引入成员函数，更好的表示函数与数据的相关性；

    将函数引入结构体内部，时c到c++的重要演变， 更像是一个类

## 从初始化和赋值语句谈起

    C++强类型语言 C++和类型密切相关
      初始化/赋值语句是C++中最基础的操作，是将某个值和对象关联起来

    --初始化：声明一个变量，为这个变量设定一个值；
            赋值语句：改变这个值的内部变量

    --值：字面值，对象『变量或常量』所表示的值
                  = 左边的值为对象时，要想表示出来要用标识符
            --标识符：变量，常量，引用...

    --初始化的基本操作：
            在内存中开辟空间，保存数值；
            在编译器中构造符号表，将标识符与相关内存空间关联起来

    初始化可能涉及的转换
            类型匹配
            int x = 10; 10赋值给x(int)时没有问题的-->类型是匹配的

## 类型详述 1

    类型是一个编译期的概念， 可执行不存在的类型概念
      C++是强类型的语言 --> 类型是存在内存中的，当完成编译的时候内存中时不存在类型的，所以类型是一个编译期的概念；
      C++引入内存是为了更好的描述程序，防止误用

    类型的描述：
            --类型存储所需尺寸（sizeof）；
                  1 word = 2 byte; 1个字=2个字节；
                  1 byte = 8 bit;  1个字节 = 8位；

    1 kb = 1024个字节；
            --取值空间(std::numeric_limits, 超过范围可能产生溢出)  二进制为什么会产生溢出？？？？？？
            --对齐信息（alignof）
            --执行的操作;
                  所以我们定义了一个什么样的类型，就决定了一个类型的操作 。比如整形就只能采用整形的操作，而不是用str
                  域之符号int『short, int, long, longlong』
                        无符号int『unsigned + 带符号整数类型』
                  浮点形：『float, double, longdouble』

    复杂类型：
            --void：
                  基本类型组合，变种所产生类型。标准库引入，或自定义类型

    C++种标准种类型未定义的部分：
            --char是否有符号；(看具体情况，不同编译器)
            --int中内存中的保存方式：大端， 小端 <--在俩台机器网络传输中，比较重要-->统一接受数据都为大端或小端
            --每种类型的大小（间接影响取值范围）
                  C++11 引入固定尺寸的整数， int32_t -->32个bit 不要认为是字节

    补充：
                  1.unsigned == usingned int  C++为了方便自我应定义一个 仅仅只针对int

    2.每个字面值都有其类型
                        --int字面值：『20（十进制）， 014（八进制）， 0x14(十六进制)』 <--int型-->
                        --浮点数：1.3， 1e8-double [1e8科学计数，代表1x10**8]       <--double型-->
                        --字符面值："c","\n","\x4d" 【\代表回车，转义字符】          <--char型-->
                        --字符串字面值："Hello"                                   <--char[6]型-->
                        --布尔字面值： true， false                               <--bool型-->
                        --指针字面值： nullptr                                    <--nullptr_t型-->

    3.根据前后缀修改字面值
                        --1.3double ---> 1.3float
                        --2int ---> 2ULL(unsigned long long)

    4.引入自定义的后缀，修改值（一般不建议这样做）域之
                        _ddd(long double x)---> long double x 为自定义后缀
                        建议阅读：User-defined literals(since C++ 11)
      变量和其类型
            --变量的申明与定义的区别
                  变量的定义：就是开辟一段空间，可以改变其内容。与变量联系起来。
                  变量的申明：extern 前缀 代表从外部引用

    --变量的初始化与赋值
                  初始化：构造变量时给其赋值                                             ？？？？？？？？？？？？？？
                        🦃缺省初始化； 要么赋值0，要么随机一个值                           ？？？？？？
                        直接/拷贝初始化； 给🦃缺省初始化一个有意义的值就是，拷贝初始化。 int x(10); 直接初始化 ？？？？？？？？？？？？？？？/
                        其他初始化；

    --变量赋值是可能涉及到的类型(隐式)转换
                  bool 与 int 之间的转换；
                  浮点数与整数之间的类型转换；

    --隐式（编译器自动完成，隐形完成）类型转换不仅发生在赋值转换
                  if 判断
                  数值比较
                        无符号与带符号数据之间的比较
                              c++一个重要规定，一个带符号的数和一个不带符号的数进行比较的时候，那么进行类型转换的时候一定是要把
                        带符号转化为无符号的值。

    std::cmp_XXX (C++)

## 非常重要的主题

## 复合指针：从指针到引用

    指针：一种间接类型
            特点：--可以指向不同的对象
                 --具有相同的尺寸
                        因此，取连续的8个字节里的内容
            相关操作：
                  & --> 取地址操作符；
                  * --> 解引用操作符； 就是直接指出指针中的地址内容
            指针的定义：
                  -- int* p = &val;
                        函数重载：同样的函数名传入不同的参数，进行处理
                  -- int* p = nullptr;
                        nullptr是一种特殊的指针 不是一个类型，是一个对象。
                        nullptr是一个特殊的对象『类型：nullptr_t』表示空指针。一般不会使用nullptr的对象类型
                        类似于c中NULL，对函数重载解析，更加的安全保证程序行为的一致性
            指针与bool的隐式转换：非空指针转化为true，反之空指针为false
            指针的主要操作：
                  -- 解引用:直接指出指针开辟内存存储地址的内容
                  -- 增加，减少： 指在计算机中内存上操作 如果为int型，即+ 为向后移动4个字节， -为向前移动四个字节。其他数据类型，以此类推；『在数组上，使用指针的相加和相减少』
                  -- 判等：
            void* 指针：
                  --没有记录对象尺寸（在内存序列位置长度）信息，可以保存任意地址
                        目的-->作为占位符，保存某个指针一些信息
                        不能对void*进行算术运算，这样是没有意义的
                  --支持判断操作

    指针的指针：
            指针复制成本底，读写成本高（需要2次的内存访问，1次是访问指针内部保存的数据，1次是根据第一次访问地址的数据（地址），访问该地址数据）
                  -- 为什么要引入指针，引入指针是为了对象的间接引用
            指针的问题：
                   -- 可以为空；
                        21_lst/main.cpp
                   -- 地址信息非法；
                   -- 解决方案： 引用
            这里重点关注：

    1.间接的引用，能减少程序的传输。减少传输所付出的成本；
                              2.实现函数传址，改变函数内部输入参数的值；
                              对象的尺寸是不同的，但是指针的尺寸是相同的

    备注：如果俩个指针不相等，不能去做 >,< 的判断, 这是非常危险的操作。程序运行的数据内存，可能一会在当前地址前面，也可能在后面。造成每次的运行结果不一样，造成程序的
                  的不稳定性。如果在栈内，则先申明某个变量， 在申明某个变量。则会满足一定的关系，保证程序稳定性 在21_lst程序中
                              如果是在堆里，则完全没普了； 所以一定要在同一个数组内比较。

    指针作为函数的参数传入，还有一个好处是我可以修改这个指针指向的内部的值。 <--- C和C++的重要概念之一 『函数是传值的，还是传址的』
                        1.间接的引用，能减少程序的传输。减少传输所付出的成本；
                        2.实现函数传址，改变函数内部输入参数的值；
                        对象的尺寸是不同的，但是指针的尺寸是相同的

    引用：
            int& ref =val;
                  & 代表声明这个函数的引用 int& ref -->int声明要对 ref进行引用
                        什么是引用：
                              引用是对象的别名；
                                    --什么叫对象的别名；

    -- 是对象的别名，不能绑定字面值
            -- 构造时绑定对象，在其生命周期内不能绑定其他对象（赋值操作会改变对象内容）
                        非常重要的理解：
                        *ptr = y; //解引用x的值，然后将y的值赋给x 改变了ptr地址内存中所指向地址的内容
                        ptr = &y;//ptr原来的地址是和x绑定的，这里强行将ptr的地址与y的地址进行了绑定， 这里改变了ptr的原地址所指向的内存位置，换成了y的地址内容
                        对比：指针要么改变指针本身，要么改变地址绑定的对象！！！！
                        引用只能通过赋值，改变引用绑定的对象
            -- 不存在空引用，但是存在非法引用 --->总的来说，比指针安全
                        指针的非法：1.解引用空指针；
                                    2.指针指向的位置不是合法对象位置；
                        引用为什么存在非法：
                              1.
            -- 属于编译期概念，在底层还是通过指针实现

    指针的引用：

    --指针是对象，因此可以定义应用：

    c语言中没有,引用这个东西, c++加入了引用为了解决指针地址为空, 指针指向地址的地址内容非法
                   保护程序

    --int* p = &val; int * &ref = p;

    --类型信息从右向左解析；

## 引用的引用

    实际上是不可以的，对象是c++里面高级的概念，在c++语法中把指针作为对象，而不把引用当做对象

## 常量类型与常量表达式

    常量类型：从三
            -- 什么是常量？
                  常量是于变量相对的，且不可修改！
                  变量是有底层硬件内存支持的，常量并没有底层硬件支持，我们不可能创造只读的内存！
                  常量编译器保证的；编译器会防止常量的写操作；
                  常量能干的事情变量都可以干，只不过常量引入了写操作！
            -- 使用const声明常量对象；
            -- 常量是编译期的概念，编译器利用其：
                  防止非法操作；（引入常量的原因）
                  优化程序逻辑；（引入常量的原因）

    -- 常量指针与顶层常量：
                  常量指针：
                        const int* ptr = &x； 代表const--> x   即x不能被修改 ，ptr指针可以被修改
                        int* const ptr = &x;  代表const--> ptr 即ptr指针内容地址不能被修改， 原始对象可以被修改
                        left|*|right :1.<--- const出现在*左边，代表原始地址中指向内容不能被修改；
                                      2.<--- const出现在*右边，代表指针中存储的地址不能被修改；
                        const int* ptr = &x;  #####底层常量 bottom-level const；
                        int* const ptr = &x;  #####顶层常量 top-level const；

    顶层常量： <-top-level const->
                        int* const ptr = &x;  #####顶层常量 top-level const；
                        const* int const p;   代表不仅是顶层常量，而且是底层常量意味着，指针的存储地址不能被修改，原始对象也不能被修改

    常量指针可以指向变量：
                        """
                              #include`<iostream>`

    int main()
                              {
                              const int x = 3;
                              const int* 元素ptr = &x;// 这里const int* ptr = const int* 这里不涉及隐式转换，完全没问题
                              }
                        """
                  常量的引用（也可以绑定变量）：
                        常量的引用也是通过指针实现的；
                        -- cost int&;
                        -- 可读但不能写；
                        -- 主要用于函数形参；
                        -- 可以绑定字面值元素
                  常量表达式：
                        -- constexpr 声明
                              解释：常量表达式，来申明编译期的常量
                        -- 声明的是编译期常量
                        -- 编译器可以利用其进行优化
                        -- 常量表达式指针： constexpr位于*左侧，但表示指针是常量表达式

# 类型别名与类型的自动推导

## 什么是类型别名

    -- 可以为类型引入别名，从而引入特殊的含义或便于使用(size_t)
                        size_t：无符号的整形，可以表示任意尺寸的对象，通过一个别名实现.
                  -- 俩种引入类型别名的方式
                        typedef int Myint;
                        using MyInt = int; (从c++11开始)
                  -- 使用using 引入类型别名更好
                        typedef char MyCharArr[4];
                        using MyCharArr = char[4];
                  -- 类型别名与指针，引用的关系
                        将指针类型别名视为一个整体，元素在此基础上引入常量表示指针为常量的类型；
                        不能通过类型别名构造引用的引用；无符号的整形，可以表示任意尺寸的对象，通过一个别名实现

## 类型的自动推导

    -- c++11 开始，可以通过初始化表达式自动推导对象类型
                  -- 自动推导类型并不意味着弱化类型，对象还是强类型
                  -- 自动推导的几种常见形式
                        auto：最常见的形式，但会产生类型退化；
                        const auto/constexpr auto；推导出的是常量/常量表达式
                        auto&：推导出引用类型，避免类型退化
                        decltype(exp):返回exp表达式的类型（左值加引用）
                        decltype(val):返回val的类型嗯
                        decltype(auto):从c++14开始，简化decltype的使用
                        concept auto: 从C++20开始支持，表示一系列类型（std::integral auto x =3;）

# 域与对象的生命周期

## 什么是域？

    -- 域(scope)表示了程序中的一部分，其中的名称有唯一的含义；
            -- 块域（block scope):使用大括号所限定的域，其中定义的是局部对象；
            -- 全局域(global scope):程序在外围的域，其中定义的是全局对象；
            -- 还存在其他的域：类域，名字与空间域...
            -- 域可以嵌套，嵌套域中定义的名称可以隐藏外部域中的定义的名称；
            -- 对象的生命周期起始于被初始化的时刻，终止于被销毁的时刻
            -- 通常来说
                  -- 全局对象的生命周期是整个程序的运行时间
                  -- 局部对象生命周期起源于对象的初始化位置，终止在域被执行完成

# 第二章总结

    1.初始化；
                        2.类型详述；
                        3.符合类型：从指针到引用；
                        4.常量与常量表达式类型；
                        5.类型别名域类型的自动推导；
                        6.域和对象的生命周期；

# 第三章

## 数组的引入

    -- 1.数组
                              将一个到多个相同的类型串联到一起，所组成的类型
                                    int a --> int b[10]
                              数组的初始化方式：
                                    缺省初始化
                                    聚合初始化 [aggregate initiazation]
                              注意事项：
                                    不能使用auto来声明数组类型；
                                    数组不能赋值；
                                          原因：这个操作非常消耗时间，根据数组length开辟一大块内存，每一个元素，进行赋值。消耗很多资源
                                    元素个数必须是一个常量表达式（编译期可计算的值）；
                                    字符串数组的特殊性；

    -- 2.vector
            -- 3.字符串
                  char str[] = "Hello"; 这种情况C++会隐式的在末尾增加\0,取值为零的字符。是用来表示这个字符串结束的。 就会变成char[6]
                  char str[] = "Hello"；==  char str[] = {'H', 'e', 'l', 'l','o'，'\0'}; type:char[6]
                  char str[] = {'H', 'e', 'l', 'l','o'};这种情况是 char[5]

    -- 4.数组的复杂声明
                        指针数组与数组的指针
                              指针数组：
                              数组的指针：
                                    他的初始化方式如下：
                                          {
                                                int b[3];
                                                int (*a)[3] = &b;
                                          }

    声明数组的引用
                                    不能声名引用的数组
                                    如下
                                    {
                                          int x1;
                                          int x2;
                                          int x3;
                                          int& a[3] = {x1, x2, x3}//本质上构造一个数组，里面有三个元算，每一个元素都是引用。
                                          //引用是对象的别名，但不是对象。但是数组里面包含着元素，一定要是对象。所以不能申明引用的数组
                                    }

    -- 5.数组中的元素访问
                              这里面的水比较深，哈哈哈哈！
                              数组对象是一个左值
                                    //l-value :放在等号左边的值，在C++当中对其进行了修改，实际上变为了locator value.在C++中一些左值没有被放到左边；
                                          氏族了指针，再进行解引用，如下所示：

    int main()
                                    {
                                    int a[3] = {1, 2, 3};
                                    //     std::cout << a[100] << std::endl; // --> result: 32767
                                    std::cout << *(a + 100) << std::endl;//将a转化为指针，向后移动100个int。超出了我们开辟3个内存的大小，即变成内存溢出。即内存访问的越届
                                    std::cout << *(a -1) << std::endl; //将a转化为指针，向前移动一位，也是超出了我们开辟3个内存的大小，即越届
                                    }

    # 从数组到指针

    -- 1.数组到指针的隐式转换
                              使用数组对象时，通常情况下会产生数组到指针的隐式转换；
                              隐式转换会丢失一部分类型信息；
                              可以通过声明引用来避免隐式转换；
                              注意：不要使用extern 指针来声明数组，如下1所示：
                                    1.--> extern int* array;//数组就会隐式的转化成指针
                                          int main()
                                          {
                                          std::cout << array[1] << std::endl;

    }

    2.--> extern int array[];
                                          /*
                                          声明，要链接到别的单元，声明. 注意这里不是定义，声明可以不给出值
                                          将array[]当作一个数组看待.
                                          在C++里这个叫做 Unknow Bounded Array 声明
                                          */

    -- 2.获得指向数组开头与结尾的指针：std::(c)begin, std::(c)end
                                    std::(c)begin 和 std::begin(a)的区别
                                          std::begin(a) -- > 获取到的是 int*的指针，根据30_lst, 可以进行读写；
                                          std::cbegin   -- > 获取的是const * 不能进行写，只能读；
                                          避免出现错误，建议采用std::cbegin, 还有他俩只能在数组下才有作用，若发生auto退化不可用，回报错

    在外部链接 extern的时候 这里当extern int array[] 时不能用，只有明确告知extern int array[5]里到底有几个元素才可以使用。
                                    extern int array[] --> std::cend 不知道有多少个结尾元素。
            #include`<iostream>`
            #include <type_traits>

    int main()
            {
            int x2[3][4];
                  auto ptr = std::begin(x2);
                  while(ptr != std::end(x2))
                  {
                        ptr = ptr + 1;
                        std::cout << ptr << std::endl;
                  }

    }
                                    俩个指针相减去，返回的时俩个指针之间包含的元素个数
                                    俩个指针相减去，返回的时俩个指针之间包含的元素个数
                              解引用；
                              指针索引；

## 数组的其他操作

    -- 1.求元素的个数
                              sizeof 方法；
                                    sizeof 不会退化为指针，他是直接在内存上取数组元素的长度
                              std::size 方法；
                                    c++ 17引入的方法 ，但是会报错。
                              (c)end - c(begin)方法；
                                    得到数组中元素的个数
                                    一个指针占8个字节，在64位机上
                                    (c)end 和 (c)begin在运行期执行
                        -- 2.元素遍历
                              基于元素的个数
                              基于(c)begin/(c)end
                              基于range-based for 循环

## C的字符串起

    -- 1.C字符串本质上也是数组
                        -- 2.C语言提供了额外的函数来支持C字符串相关的操作：strlen， strcmp ...
                              strlen：字符串的长度
                                    声明字符数组 char str[] = "hello";最好使用双引号这种
                                    或是——————> char str[] = {'h', 'e', 'l', 'l', ''o,'\0'}; \0表示终止处理;
                              strcmp: 用来比较字符串

## 多维数组

    什么是一维数组 --> int a -- int b[10]

    -- 1.数组的本质；
                              int a[3][4][5];的分析

    -- 2.多维数组的聚合初始化；
                              一层大括号 v.s. 多层大括号
                                    多层大括号：聚合初始化{{}}能更好的说明为那个元素初始化；

    -- 3.多维数组的索引与遍历;
                              使用多个中括号来索引;
                              使用多重循环来遍历;

    -- 4.指针与多维数组
                              多维数组可以隐式的转换为指针, 只会发生在最高维,其他维度的信息被保留;
                              使用类型别名来简化多维数组指针的声明;
                                    #include`<iostream>`
                                    #include <type_traits>

    using A = int[4]; //类型别名简化多维数组
                                    int main()
                                    {
                                          A x2[3];
                                          // A x2[3] 等价于 x2[3][4]; 维度信息的不一致.维度信息变成底到高的排列,在Vecftor,或其他方式定义多维数组时维度会变成从低到高排列
                                          A* ptr = x2;
                                    }
                              使用指针来遍历多维数组

## Vector

    -- 1. 是C++ 标准库中定义的一个类模板;

    -- 2. 与内建数组相比,更侧重于易用性;
                        可复制,可在运行期间动态改变元  4;4;4;素个数
                              数组不支持复制.但是Vector支持,std::vector`<int>` x;//vector `<int>`是x的类型   vector的主要作用

    -- 3.构造与初始化;
                        聚合初始化
                        其他的初始化方法
                                vector的易用性是一牺牲程序性能为代价的；

    -- 4.其他方法;
                        获取元素个数,判断是否为空
                        插入,删除元素  //在运行期间
                        vector的比较 //在运行期间

    -- 5.vector中元素的索引和遍历
                        [] V.S.at
                              at的好处再于防止数组x[-1]和vector用[]这种类的越界
                        (c)begin /(c)end函数  V.S. (c)begin/(c)end 方法

    -- 6.迭代器(iterator)
                  模拟指针的行为；
                  包含多种类别，每种类别支持操作不同；
                  vector 对应随机访问迭代器；
                        解引用与下标访问；
                        移动；
                        2个迭代器相减少求距离；
                        2个迭代器比较；

    -- 7.vector相关的其他内容
                  添加元素；
                        x1.push_back(2);
                        x1.pop_back();//弹出最后一个元素
                        添加元素使得迭代器失效,请看34_lst
                  多维vector；
                        std::vector[std::vectorint&lt;; x; // create 2 dim array]

[
    从. 到-; 操作符
                        x4.size();//x4是一个对象。所以我们可以构造的他的指针；
                        std::cout &lt;&lt; 4;-;: 4; &lt;&lt; ptr-;size() &lt;&lt; 4;\n4;; //特点箭头左边一定是指针，直接调用对象x4的方法；]

[
    vector内部定义的类型
                        size_type;
                        iterator/const_iterator;]

## String


    -- 1.是C++ 标准库种定义的一类模板特别化名，用于内建字符串的替代品；]


    -- 2.与内建字符串相比，更侧重于易用性；
                        可复制，可在运行期动态改变字符个数]


    -- 3.构造与初始化；]


    -- 4.其他方法；
                        尺寸相关方法(size/ empty)
                        比较
                        赋值
                        拼接
                        索引
                        转化为c字符串]

# 第四章 表达式

## 表达式基础


    -- 1.什么是表达式
                  表达式是由一到多个操作数组成,可以求值并(通常情况)返回结果;
                        引入表达式的目的要么求返回结果,要么进行副作用.表达式还可以嵌入,小的表达式组成大的表达式.
                        函数调用也是表达式.
                  列外情况(无返回结果):


    最基本的表达式
                        变量,字面值;
                  表达式包含操作符(运算符);
                  操作符的特性:
                        接受几个操作数:一元, 二元, 三元
                                    一元:只能接受一个操作符 如 3;
                                    二元:只能接受一个操作符 如 3 + 2;
                                    三元:c++里面只有一个唯一的三元操作符:  true ？ 3：4;
                        操作数的类型 ---; 类型转换
                  操作数是左值还是右值;
                  结果的类型;
                        操作数是左值还是右值 --; 结果也有左值和右值域值
                  优先级与结合型cpp-reference,可以通过小括号来改变运算顺序
                  操作符的重载---; 不改变接受操作数的个数,优先级与结合性
                        在学习完类后,才会来看操作符的重载.操作符可以重载,只能改变运算本身的含义
                  操作数求值顺序的不确定性;


    -- 2.传统的左值和右值
                  c语言:左值放在等号左边,右值放在等号右边;
                  c++语言:左值和右边不一定都放在等号左边或右边;


    -- 3.所有对左值和右边的划分,都是针对表达式的,或是表达式的求值结果;
                  glvalue: 表示一个对象,位域,或函数
                        什么是位域:即一个字节,占8个bit,某一个字节当中,具体的位置;
                        泛左值: 表示一个对象,位域,或函数 不会变成将亡值.
                  prvalue: 用于初始化对象或作为操作数
                        纯右值:要么是一个将亡值,即如果表示一个对象即将消亡
                              其次:用来初始化对象,或是用作操作符的操作数的时候
                  xvalue:  表示资源可以被重新使用


    注意看代码:
                       #include "<iostream>"
                        #include "<vector>"


                        struct Str
                        {

                         };
                        void fun(std::vector `<int>`&amp;&amp;  par) //&amp;&amp; 是右值引用. fun函数接受名为:par的参数
                        {

                        };


                        int main()
                        {
                        // int x  = 3; //x =3 进行了初始化,  = 不是运算符
                        // x = 3;//没有封号是表达式,加了封号是语句]
                        // int{}; //构造一个随机对象,缺省初始化.用于操作符的操作数,初始化,认为是pvalue
                        // Str{}; //构造一个随机对象,缺省初始化]

                        std::vector `<int>` x;//再运行期动态改变数组的大小,保存相应的数据
                        fun(std::move(x));
                        /*
                        1. std::move() --; c++的标准函数, 使用std::vector `<int>` x 构造std::move(x)的值.
                        std::vector `<int>` x 是glvalue]


                        2. std::move(x) --;将std::vector `<int>` x 中的x转为将亡值(expiring).]

                        3.将亡值(expiring) 利用std::move(x)去调用fun函数,即将std::move(x)的信息传递给par,
                                                由于std::move(x)是一个prvalue引用(将亡值),表明后续在main中我不会再对x中包含的资源进行任何处理]
                         }
            
            -- 4. 左值与右值的转换
                        左值转为右值; glvalue --;prvalue
                              我们在表达式某个地方需要的是右值,但是我们可以提供相应的左值,因为编译器会把他进行处理当作右值来处理
                        临时具体化; pralue --;xvalue   &lt;--39_lst--;
            -- 5. 再论decltype
                        prvalue --; type;
                        lvalue  --; type&;
                        xvalue  --; type&&;
                              若实参类型为T,则
                              1).若表达式的类型为xvalue,则decltype产生T&&;
                              2).若表达式的类型为glvalue,则decltype产生T&;
                              3).若表达式的类型为pvalue,则decltype产生T;
                        std::move()--;将ralue变为xvalue将亡值]

## 表达式详述


    共分为三个优先级
            -- 1.算术操作符
                  共分为三个优先级
                        +, - (一元);
                        *, /, %
                        +, - (二元)
                  一元二元指的是接受几个操作数; 一元接受一个操作数,二元接受俩个操作数;
            -- 2.均为左结合;
            -- 3.通常来说,操作数与结果均为算术类型的右值;但+, -法与一元 + 可接受指针;
            -- 4.一元 + 操作符会产生integral promotion;
            -- 5.整数相除会产生整数,向0取整数;
            -- 6.求余只能接受整数类型操作数,结果符号与第一个操作数相同;
            -- 7.满足(m/n) + m%n == m;

    逻辑与关系操作符
            -- 1.关系操作符接受算术或指针类型操作数; 逻辑操作符接受可转换为bool值的操作数
            -- 2.操作数与结果均为右值位置
            -- 3.除逻辑非外,其他操作符都是左给的
            -- 4.逻辑与的优先级高于逻辑或


            -- 5.通常来说,不能将多个关系操作符串联
            -- 6.不要写出 value = true这样的代码
            -- 7.逻辑与,逻辑或具有短路特性;
            -- 8.Sapceshipe operator: <=>;
            这里不清楚，需要再再次查看视频41

    位操作符
            -- 1.接受右值，进行位运算，返回右值
            -- 2.除取反外，其他运算符均为左结合的
            -- 3.注意计算过程中可能会涉及到的integral promotion
            -- 4.注意这里没有短路逻辑
            -- 5.位移操作在一定情况下等价于乘(除)2的幂，但速度更快
            -- 6.注意整数的符号与位操作符的相关影响
                        integral promotion 会根据整数的符号影响其结果
                        右移保持符号，单左移不能保证

    赋值操作符
            -- 1.左操作数为可修改左值；右操作数为右值，可以转换为左操作数的类型；
            -- 2.赋值操作符是右结合的；
            -- 3.求职结果为左操作数；
            -- 4.可以引入大括号(初始化列表)以防止收缩转换（narrowing conversion）
                        就是，数值提升：小类型变大类型， 大类型反之，有些情况小类型能变为大类型。
                  有些情况下表示不了,采取的做法加一个大括号！
                        const和constexpr的区别：
                              const：不要求，再编译时就能被计算出；（有了初始值，只读）
                              constexpr：定义的变脸，要求再编译时就能被算出，只能由常量表达式赋值（没初始化的时候，就是一个常量）
            -- 5.小心区分 =与==
                  =：赋值操作符
                  ==： 逻辑判断符
            -- 6.复合赋值云算符

     自增与自减运算符
            -- 1.++；--；
            -- 2.分前缀与后缀俩种情况；
            -- 3.操作数为左值；前缀时返回左值；后缀时返回右值；
            -- 4.建议使用前缀形式；

     其它操作符
            -- 1.成员访问操作符：.与->
                  ->等价于(*);
                        用在结构体和类中，访问变量；
                  .的左操作数是左值(或右值)，返回左值(或右值xvalue)
                        decltype();为实体
                        decltype(());为表达式的写法
                  ->的左操作数指针，返回左值
            -- 2.条件操作符
                  唯一的三元操作符
                        一元操作符：正号+，负号-
                        二元操作符： +， -，*， /
                        三元操作符：
                  接受一个可转换为bool的表达式与2个类型相同的表达式，只有一个表达式会被求值
                  如果表达式均是左值则返回左值，否则为右值
                  右结合；

            -- 3.逗号操作符
                  确保操作数会被从右向左求职；
                  求职结果为右操作数；
                  左结合；

            -- 4.sizeof操作符
                  操作数可以是一个类型或一个表达式；
                  并不会实际求值，而是返回相应的尺寸，便于后期查看；
            
            -- 5.其他操作符
                  域解析操作符；
                  函数调用操作符()；
                  索引操作符[];
                  抛出异常操作符 throw；


## C++17 对表达式的求值顺序限定
      以下表达式再c++17中，可以确保e1会先与e2被求值
            -- 1.e1[e2];
            -- 2.e1.e2;     // .为成员访问操作符
            -- 3.e1.*e2;
            -- 4.e1->e2;   // 指向结构图或类的元素
            -- 5.e1 << e2;
            -- 6.e2 >> e2;
            -- 7.e2 = e1/e2 += e1/e2 = e1...(赋值机赋值相关的符合运算)

      newType(e) 会确保e会在分配内存之后求值

      
## 第4章总结
    本章 表达式基础， 表达式详述， C++17对表达式的求职顺序的限定




